---
title: Mmseq_find_coregenes
output: html_document
date: "2025-04-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
You should have run the first script (extract_gene_) before this script because you need the extracted organized information from mmseq tsv file that will be matched here to identify the core genes.
Other files needed here is the concatenated genbank file of all the phages involved (in this case, nine). 
#Take a look at the mmseq cluster file
```{r load_libraries}
# Load required libraries
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

# Try to load Biostrings, install if not available
if (!requireNamespace("Biostrings", quietly = TRUE)) {
  BiocManager::install("Biostrings")
}
library(Biostrings)  # For reading FASTA files

# Load seqinr for GenBank parsing
if (!requireNamespace("seqinr", quietly = TRUE))
  install.packages("seqinr")
library(seqinr)

library(patchwork)

# Set working directory
setwd("")

# 1. Load the clusters.tsv file
cat("Loading cluster file...\n")
all_clusters <- read.delim("reorganized_phage_clusters.tsv", 
                           header = TRUE, sep = "\t", stringsAsFactors = FALSE)

cat("Found", nrow(all_clusters), "clusters in the input file\n")

# 2. Extract all protein IDs from the clusters
extract_protein_ids <- function(members_string) {
  if (is.na(members_string)) return(character(0))
  members <- unlist(strsplit(members_string, "\\|"))
  return(members)
}

all_proteins <- unique(unlist(lapply(all_clusters$Members, extract_protein_ids)))
cat("Found", length(all_proteins), "unique proteins in clusters\n")
```


# Extract protein annotation info from the concatenated gbk file of all phages
```{r,}
#3. Parse the GenBank file
extract_annotations_from_gbk <- function(gbk_file) {
  gbk_raw <- readLines(gbk_file)
  
  annotations <- data.frame(
    ID = character(),
    Product = character(),
    Function = character(),
    stringsAsFactors = FALSE
  )
  
  in_cds <- FALSE
  cds_lines <- c()
  
  extract_field <- function(lines, tag) {
    match <- grep(paste0(tag, '="'), lines, value = TRUE)
    if (length(match) > 0) {
      sub(paste0('.*', tag, '="([^"]+)".*'), "\\1", match[1])
    } else {
      NA
    }
  }
  
  for (line in gbk_raw) {
    if (grepl("^\\s{5}CDS", line)) {
      # Start a new CDS
      if (in_cds) {
        # Process the previous CDS block
        locus_tag <- extract_field(cds_lines, "/locus_tag")
        protein_id <- extract_field(cds_lines, "/protein_id")
        product <- extract_field(cds_lines, "/product")
        function_ <- extract_field(cds_lines, "/function")
        note <- extract_field(cds_lines, "/note")
        
        # Prefer locus_tag > protein_id > auto-ID
        id <- if (!is.na(locus_tag)) locus_tag else if (!is.na(protein_id)) protein_id else NA
        if (!is.na(id)) {
          annotations <- rbind(annotations, data.frame(
            ID = id,
            Product = ifelse(!is.na(product), product, "unknown product"),
            Function = ifelse(!is.na(function_), function_, ifelse(!is.na(note), note, "unknown function")),
            stringsAsFactors = FALSE
          ))
        }
      }
      in_cds <- TRUE
      cds_lines <- line
    } else if (in_cds && grepl("^\\s{21,}/", line)) {
      cds_lines <- c(cds_lines, line)
    } else if (in_cds && grepl("^\\s{5}\\S", line)) {
      # End of CDS block, process it
      locus_tag <- extract_field(cds_lines, "/locus_tag")
      protein_id <- extract_field(cds_lines, "/protein_id")
      product <- extract_field(cds_lines, "/product")
      function_ <- extract_field(cds_lines, "/function")
      note <- extract_field(cds_lines, "/note")
      
      id <- if (!is.na(locus_tag)) locus_tag else if (!is.na(protein_id)) protein_id else NA
      if (!is.na(id)) {
        annotations <- rbind(annotations, data.frame(
          ID = id,
          Product = ifelse(!is.na(product), product, "unknown product"),
          Function = ifelse(!is.na(function_), function_, ifelse(!is.na(note), note, "unknown function")),
          stringsAsFactors = FALSE
        ))
      }
      in_cds <- FALSE
      cds_lines <- c()
    }
  }
  
  # Final CDS
  if (in_cds && length(cds_lines) > 0) {
    locus_tag <- extract_field(cds_lines, "/locus_tag")
    protein_id <- extract_field(cds_lines, "/protein_id")
    product <- extract_field(cds_lines, "/product")
    function_ <- extract_field(cds_lines, "/function")
    note <- extract_field(cds_lines, "/note")
    
    id <- if (!is.na(locus_tag)) locus_tag else if (!is.na(protein_id)) protein_id else NA
    if (!is.na(id)) {
      annotations <- rbind(annotations, data.frame(
        ID = id,
        Product = ifelse(!is.na(product), product, "unknown product"),
        Function = ifelse(!is.na(function_), function_, ifelse(!is.na(note), note, "unknown function")),
        stringsAsFactors = FALSE
      ))
    }
  }
  
  return(annotations)
}

annotations <- extract_annotations_from_gbk("~/Documents/Manuscript_TayeBlu_R_analysis/MMseq2_reorderedupdated/TayeBlu9.gbk")
cat("Extracted", nrow(annotations), "protein annotations\n")
write.table(annotations, "protein_annotations.tsv", sep = "\t", quote = FALSE, row.names = FALSE)

```

## Merge MMseq cluster tsv with annotation protein_annotations.tsv
```{r}
library(dplyr)

# STEP 1: Read the cluster file
cluster_data <- read.delim("reorganized_phage_clusters.tsv", header = TRUE, sep = "\t", stringsAsFactors = FALSE)

# Rename Cluster_ID to ID for merging
names(cluster_data)[names(cluster_data) == "New_Rep"] <- "ID"

# I don't know why dplyr refused to work, so I had to use base R as seen above
#cluster_data <- cluster_data %>%
 #rename(ID = "New_Rep")

# STEP 2: Read the annotation file
#annotations <- read.delim("protein_annotations.tsv", header = TRUE, sep = "\t", stringsAsFactors = FALSE)

annotations <- read.delim("protein_annotations.tsv", header = TRUE, sep = "\t", stringsAsFactors = FALSE, quote = "")

# Remove whitespace and any text after a pipe (|) or space
cluster_data$ID <- trimws(cluster_data$ID)
annotations$ID <- trimws(annotations$ID)

# If any ID has extra trailing stuff like "TayeBlu_1|abc" â†’ keep only "TayeBlu_1"
#annotations$ID <- gsub("\\|.*", "", annotations$ID)
#cluster_data$ID <- gsub("\\|.*", "", cluster_data$ID)

# STEP 3: Merge using the representative ID (formerly Cluster_ID)
annotated_clusters <- cluster_data %>%
  left_join(annotations, by = "ID")

# STEP 4: Check if any annotations were missed
unmatched <- annotated_clusters %>% filter(is.na(Product))
cat("Unmatched proteins in cluster merge:", nrow(unmatched), "\n")

# STEP 5: Save the result
write.table(annotated_clusters, "cluster_annotated.tsv", sep = "\t", row.names = FALSE, quote = TRUE)

```

```{r pressure, echo=FALSE}

font_family = "Avenir Next Condensed"

# Load the annotated proteins file
# protein_data <- read.delim("cluster_annotated.tsv", header = TRUE, sep = "\t", quote = "\"", stringsAsFactors = FALSE, fill = TRUE)

library(ggplot2)

# Function to categorize gene functions into broader categories
categorize_function <- function(func) {
  if (is.na(func) || func == "" || grepl("unknown|hypothetical|uncharacterized", func, ignore.case = TRUE)) {
    return("unknown function")
  } else if (grepl("tail|fiber|spike|baseplate|connector", func, ignore.case = TRUE)) {
    return("tail")
  } else if (grepl("head|capsid|portal|terminase|scaffolding|structural|packaging", func, ignore.case = TRUE)) {
    return("head and packaging")
  } else if (grepl("lysi|holin|endolysin|peptidoglycan|spanin", func, ignore.case = TRUE)) {
    return("lysis")
  } else if (grepl("transcription|regulator|repressor", func, ignore.case = TRUE)) {
    return("transcription")
  } else if (grepl("dna|rna|polymerase|helicase|nuclease|primase|replicat|endonuclease|exonuclease|metabolism", func, ignore.case = TRUE)) {
    return("DNA/RNA processing")
  } else {
    return("other")
  }
}

# Apply function categorization
annotated_clusters$Function_Category <- sapply(annotated_clusters$Function, categorize_function)

# Correctly extract the unique phage count from the Members column
annotated_clusters$Unique_Phage_Count <- sapply(annotated_clusters$Members, function(x) {
  if (is.na(x) || x == "") return(0)
  # Split by pipe and extract the phage name part from each member
  members <- unlist(strsplit(x, "\\|"))
  # Extract phage names by removing the part after the underscore
  phage_names <- sapply(members, function(m) sub("_[^_]+$", "", m))
  # Return the count of unique phage names
  return(length(unique(phage_names)))
})

# Define the custom color scheme
custom_colors <- c(
  "unknown function" = "#AAAAAA",
  "other" = "#1E90FF",
  "tail" = "#D2691E",
  "transcription" = "#001eff",
  "DNA/RNA processing" = "#f000ff",
  "lysis" = "#9400D3",
  "head and packaging" = "#006400"
)

# Count proteins in each function category and get total phage counts
category_stats <- annotated_clusters %>%
  group_by(Function_Category) %>%
  summarize(
    Count = n(),
    Total_Members = sum(Unique_Phage_Count),
    Mean_Phage_Count = mean(Unique_Phage_Count),
    Median_Phage_Count = median(Unique_Phage_Count),
    .groups = 'drop'
  ) %>%
  arrange(desc(Mean_Phage_Count))

# Display the category stats in console for review
print(category_stats)

# Create a more informative label for each category
category_stats$Label <- paste0(
  category_stats$Function_Category, 
  " (n=", category_stats$Count, ")"
)

# Order categories by their mean phage count
annotated_clusters$Function_Category <- factor(
annotated_clusters$Function_Category, 
  levels = category_stats$Function_Category
)

# Update the factor levels with the new labels
label_mapping <- setNames(category_stats$Label, category_stats$Function_Category)
annotated_clusters$Function_Label <- label_mapping[annotated_clusters$Function_Category]
annotated_clusters$Function_Label <- factor(
  annotated_clusters$Function_Label, 
  levels = category_stats$Label
)

# Create the violin plot with specific color scheme and x-axis from 1-9
bplot <- ggplot(annotated_clusters, aes(x = Unique_Phage_Count, y = Function_Label)) +
  geom_violin(aes(fill = Function_Category), scale = "width", trim = TRUE) +
  geom_boxplot(width = 0.2, outlier.shape = NA, alpha = 0.5) +
  stat_summary(fun = "mean", geom = "point", shape = 23, size = 3, fill = "white") +
  scale_fill_manual(values = custom_colors) +
  scale_x_continuous(breaks = 1:9, limits = c(0.5, 9.5)) +
  labs(
    title = NULL,
    x = "Number of unique phages represented in cluster",
    y = "Number of clusters by function category",
    caption = ""
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 18),
    axis.text.x = element_text(size = 18),
    axis.title.x = element_text(size = 22),
    axis.title.y = element_text(size = 22),
     text = element_text(family = font_family),
    legend.position = "none",
    plot.title = element_text(hjust = 3.5, face = "bold", family = font_family),
    panel.grid.major.x = element_line(color = "gray90"),
    panel.grid.minor.x = element_blank()
  )

# Save the plot
#ggsave("totalgene_function_phage_distribution.pdf", width = 10, height = 8)
ggsave("totalgene_function_phage_distribution.png", width = 10, height = 8, dpi = 500)

# Create a summary table with complete details
function_summary <- annotated_clusters %>%
  group_by(Function_Category) %>%
  summarize(
    Total_Proteins = n(),
    Total_Unique_Phages = sum(Unique_Phage_Count),
    Mean_Phage_Count = mean(Unique_Phage_Count),
    Median_Phage_Count = median(Unique_Phage_Count),
    Max_Phage_Count = max(Unique_Phage_Count),
    Min_Phage_Count = min(Unique_Phage_Count),
    .groups = 'drop'
  ) %>%
  arrange(desc(Mean_Phage_Count))

# Write the summary table to a file
write.table(function_summary, "totalgene_function_phage_summary.tsv", 
            sep = "\t", row.names = FALSE, quote = FALSE)
```

# Heatmap of the protein distribution
```{r}
# Create a heatmap showing distribution of proteins by function and cluster size
# First prepare the data for the heatmap
heatmap_data <- annotated_clusters %>%
  group_by(Function_Category, Unique_Phage_Count) %>%
  summarize(Count = n(), .groups = 'drop')

# Define the core or near core genes to highlight
core_clusters <- data.frame(
  Function_Category = c("DNA/RNA processing", "tail","tail", "head and packaging"),
  Unique_Phage_Count = c(8, 8, 9, 9)
)

# Create the heatmap with the same color scheme as the violin plot
hplot <- ggplot(heatmap_data, aes(x = Unique_Phage_Count, y = Function_Category, fill = Count)) +
  geom_tile(color = "white", size = 0.5) +
  geom_text(aes(label = Count), color = "black", size = 8, family = font_family) +
  scale_x_continuous(breaks = 1:9, expand = c(0, 0)) +
 scale_fill_gradient(low = "#f7f7f7", high = "#4169E1") +
  labs(
    title = NULL,
     x = "Number of unique phages represented in cluster",
     y = NULL,
    fill = "Number of protein clusters"
  ) +
  # Add red box highlights for core clusters
  geom_tile(data = core_clusters, 
            aes(x = Unique_Phage_Count, y = Function_Category),
            fill = NA, color = "red", size = 1.5) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 18),
    axis.title.x = element_text(size = 22),
    #axis.title.y = element_text(size = 14),
     text = element_text(family = font_family),
    legend.position = "right",
    legend.title = element_text(size = 20),
    legend.text = element_text(size = 18)  
  )

# Save the heatmap
ggsave("totalfunction_phage_heatmap.png", width = 10, height = 6, dpi = 350)

bplot + hplot + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(family = "Avenir Next Condensed", face = "bold", size = 24))
ggsave("combinedfunction_phage_heatmap.png", width = 18, height = 8, dpi = 350)
```
